Here we briefly explain how we implemented the application of paint on a workpiece and the simulation of running paint if to much paint was applied. The paint application is based on the Asset [ProjectionSpray](https://github.com/sugi-cho/Unity-ProjectionSpray-v2). `CustomDrawingController`, `CustomSpotDrawer` and `CustomDrawables` which are described in the following are custom versions of the corresponding scripts provided by the asset.

1. The starting point is the `CustomDrawingController` which is extended by the `SprayGun` which calls the `Draw` method every frame while the trigger of the spray gun is pressed. In the `Draw` method the `CustomSpotDrawer` is used which can be imagined as a spot light pointing on the workpiece and adds paint on the respective areas of the workpiece every frame. The paint applied to the workpiece is controlled by the `cookie` which is an image defined in the `PaintController`. In our case the `cookie` is shaped like an ellipse which is the normal spraying pattern of a spray gun. The `Draw` method in the `CustomDrawingController` scales the cookie in dependence of the speed of the spray gun. Otherwise there would be gaps between to cookie applications because the frame rate is limited.

2. The `CustomSpotDrawer` calls the `Draw` method in the `CustomDrawable` script which is added to every workpiece. Here a texture is created (`heightmapOutput`) presenting the thickness of the coat for the different areas of the workpiece. The paint thickness is encoded in the 4 color channels. *r* is the thickness of the paint applied from a range further away than the maximum spraying distance (defined in the coat), *g* is the thickness of the paint applied from a range closer than the minimum spraying distance, *b* is the general thickness of the paint but reduced on greater distances, and *a* is the general thickness of the paint independent of the distance. In a prior state of the application the *r* and the *g* channel were used to visualize the dominant spray distance on the workpiece. This was removed and now the *a* channel is used mainly. 

3. Once every `FixedUpdate` the `UpdateWorkpiece` method of the `CustomDrawable` script is called. Here the surface of the workpiece is controlled in dependence of the heightmap texture. That means color, metallic strength, occlusion and the roughness is calculated with the help of shaders.

4. At the end of every `FixedUpdate` we also calculate the running paint in the `SimulatePaintRun` method which modifies the heightmap texture. The paint thickness encoded in a pixel is influenced by the neighbouring pixels. To determine the neighbouring pixel the orientation of the workpiece is considered. For implementation details see the `SimulateDrip` shader.